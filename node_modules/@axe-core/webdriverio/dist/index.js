"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AxeBuilder: () => AxeBuilder,
  default: () => AxeBuilder
});
module.exports = __toCommonJS(src_exports);
var import_fs = __toESM(require("fs"));
var import_assert2 = __toESM(require("assert"));
var import_cssesc = __toESM(require("cssesc"));

// src/utils.ts
var import_assert = __toESM(require("assert"));
var FRAME_LOAD_TIMEOUT = 1e3;
var isWebdriverClient = (client) => {
  if (!client) {
    return false;
  }
  if (typeof client.execute !== "function") {
    return false;
  }
  if (typeof client.switchToFrame !== "function") {
    return false;
  }
  return true;
};
var normalizeContext = (includes, excludes, disabledFrameSelectors) => {
  const base = {
    exclude: []
  };
  if (excludes.length && Array.isArray(base.exclude)) {
    base.exclude.push(...excludes);
  }
  if (disabledFrameSelectors.length && Array.isArray(base.exclude)) {
    const frameExcludes = disabledFrameSelectors.map((frame) => [frame, "*"]);
    base.exclude.push(...frameExcludes);
  }
  if (includes.length) {
    base.include = includes;
  }
  return base;
};
var logOrRethrowError = (error) => {
  (0, import_assert.default)(error instanceof Error, "An unknown error occurred");
  if (error?.seleniumStack?.type === "StaleElementReference" || error.name === "stale element reference") {
    console.error(
      "Tried to inject into a removed iframe. This will not affect the analysis of the rest of the page but you might want to ensure the page has finished updating before starting the analysis."
    );
  } else {
    throw new Error(error.message);
  }
};
var promisify = (thenable) => {
  return new Promise((resolve, reject) => {
    thenable.then(resolve, reject);
  });
};
var axeSourceInject = async (client, axeSource) => {
  await assertFrameReady(client);
  return promisify(
    // Had to use executeAsync() because we could not use multiline statements in client.execute()
    // we were able to return a single boolean in a line but not when assigned to a variable.
    client.executeAsync(`
      var callback = arguments[arguments.length - 1];
      ${axeSource};
      window.axe.configure({
        branding: { application: 'webdriverio' }
      });
      var runPartial = typeof window.axe?.runPartial === 'function';
      callback(runPartial);
    `)
  );
};
async function assertFrameReady(client) {
  try {
    const timeoutPromise = new Promise((resolve, reject) => {
      setTimeout(() => {
        reject();
      }, FRAME_LOAD_TIMEOUT);
    });
    const executePromise = client.execute(() => {
      return document.readyState === "complete";
    });
    const readyState = await Promise.race([timeoutPromise, executePromise]);
    (0, import_assert.default)(readyState);
  } catch {
    throw new Error("Page/Frame is not ready");
  }
}
var axeRunPartial = (client, context, options) => {
  return promisify(
    client.executeAsync(
      `
      var callback = arguments[arguments.length - 1];
      var context = ${JSON.stringify(context)} || document;
      var options = ${JSON.stringify(options)} || {};
      window.axe.runPartial(context, options).then(function (partials) {
        callback(JSON.stringify(partials))
      });`
    ).then((r) => deserialize(r))
  );
};
var axeGetFrameContext = (client, context) => {
  return promisify(
    // Had to use executeAsync() because we could not use multiline statements in client.execute()
    // we were able to return a single boolean in a line but not when assigned to a variable.
    client.executeAsync(`
      var callback = arguments[arguments.length - 1];
      var context = ${JSON.stringify(context)};
      var frameContexts = window.axe.utils.getFrameContexts(context);
      callback(frameContexts)
    `)
  );
};
var axeRunLegacy = (client, context, options, config) => {
  return promisify(
    client.executeAsync(
      `var callback = arguments[arguments.length - 1];
      var context = ${JSON.stringify(context)} || document;
      var options = ${JSON.stringify(options)} || {};
      var config = ${JSON.stringify(config)} || null;
      if (config) {
        window.axe.configure(config);
      }
      window.axe.run(context, options).then(function (axeResults) {
        callback(JSON.stringify(axeResults))
      });`
    ).then((r) => deserialize(r))
  );
};
var axeFinishRun = (client, axeSource, partialResults, options) => {
  const sizeLimit = 15e6;
  const partialString = JSON.stringify(
    partialResults.map((res) => JSON.stringify(res))
  );
  function chunkResults(result) {
    const chunk = JSON.stringify(result.substring(0, sizeLimit));
    return promisify(
      client.execute(
        `
        window.partialResults ??= '';
        window.partialResults += ${chunk};
        `
      )
    ).then(() => {
      if (result.length > sizeLimit) {
        return chunkResults(result.substr(sizeLimit));
      }
    });
  }
  return chunkResults(partialString).then(() => {
    return promisify(
      client.executeAsync(
        `var callback = arguments[arguments.length - 1];
      ${axeSource};
      window.axe.configure({
        branding: { application: 'webdriverio' }
      });

      var partialResults = JSON.parse(window.partialResults).map(res => JSON.parse(res));
      var options = ${JSON.stringify(options || {})};
      window.axe.finishRun(partialResults, options).then(function (axeResults) {
        callback(JSON.stringify(axeResults))
      });`
      )
    );
  }).then((r) => deserialize(r));
};
var configureAllowedOrigins = (client) => {
  return promisify(
    client.execute(`
      window.axe.configure({ allowedOrigins: ['<unsafe_all_origins>'] })
    `)
  );
};
function deserialize(s) {
  return JSON.parse(s);
}

// ../../node_modules/cross-dirname/dist/esm/index.mjs
var EXTRACT_PATH_REGEX = /@?(?<path>[file:\/\/]?[^\(\s]+):[0-9]+:[0-9]+/;
var WIN_POSIX_DRIVE_REGEX = /^\/[A-Z]:\/*/;
var getPathFromErrorStack = () => {
  let path = "";
  const stack = new Error().stack;
  if (!stack) {
    console.warn("Error has no stack!");
    return path;
  }
  let initiator = stack.split("\n").slice(4, 5)[0];
  if (!initiator) {
    initiator = stack.split("\n").slice(3, 4)[0];
  }
  if (initiator) {
    path = EXTRACT_PATH_REGEX.exec(initiator)?.groups?.path || "";
  }
  if (!initiator || !path) {
    console.warn("Can't get path from error stack!");
  }
  return path;
};
var getPath = () => {
  let path = getPathFromErrorStack();
  const protocol = "file://";
  if (path.indexOf(protocol) >= 0) {
    path = path.slice(protocol.length);
  }
  if (WIN_POSIX_DRIVE_REGEX.test(path)) {
    path = path.slice(1).replace(/\//g, "\\");
  }
  return path;
};
var getFilename = () => {
  let filename = getPath();
  return filename;
};

// src/index.ts
var import_url = require("url");
var axeCorePath = "";
async function loadAxePath() {
  if (typeof require === "function" && typeof require.resolve === "function") {
    axeCorePath = require.resolve("axe-core");
  } else {
    const { createRequire } = await import("module");
    const filename = (0, import_url.pathToFileURL)(getFilename()).toString();
    const require2 = createRequire(filename);
    axeCorePath = require2.resolve("axe-core");
  }
}
loadAxePath();
var AxeBuilder = class {
  client;
  axeSource;
  includes = [];
  excludes = [];
  option = {};
  disableFrameSelectors = [];
  legacyMode = false;
  errorUrl;
  constructor({ client, axeSource }) {
    (0, import_assert2.default)(
      isWebdriverClient(client),
      "An instantiated WebdriverIO client greater than v5 is required"
    );
    this.client = client;
    this.errorUrl = "https://github.com/dequelabs/axe-core-npm/blob/develop/packages/webdriverio/error-handling.md";
    if (axeSource) {
      this.axeSource = axeSource;
    } else {
      try {
        this.axeSource = import_fs.default.readFileSync(axeCorePath, "utf-8");
      } catch (e) {
        throw new Error(
          "Unable to find axe-core source. Is axe-core installed?"
        );
      }
    }
  }
  /**
   * Disable injecting axe-core into frame(s) matching the
   * given CSS `selector`. This method may be called any number of times.
   */
  disableFrame(selector) {
    this.disableFrameSelectors.push((0, import_cssesc.default)(selector));
    return this;
  }
  /**
   * Selector to include in analysis.
   * This may be called any number of times.
   */
  include(selector) {
    this.includes.push(selector);
    return this;
  }
  /**
   * Selector to exclude in analysis.
   * This may be called any number of times.
   */
  exclude(selector) {
    this.excludes.push(selector);
    return this;
  }
  /**
   * Set options to be passed into axe-core
   */
  options(options) {
    this.option = options;
    return this;
  }
  /**
   * Limit analysis to only the specified rules.
   * Cannot be used with `AxeBuilder#withTags`
   */
  withRules(rules) {
    rules = Array.isArray(rules) ? rules : [rules];
    this.option.runOnly = {
      type: "rule",
      values: rules
    };
    return this;
  }
  /**
   * Limit analysis to only specified tags.
   * Cannot be used with `AxeBuilder#withRules`
   */
  withTags(tags) {
    tags = Array.isArray(tags) ? tags : [tags];
    this.option.runOnly = {
      type: "tag",
      values: tags
    };
    return this;
  }
  /**
   * Set the list of rules to skip when running an analysis.
   */
  disableRules(rules) {
    rules = Array.isArray(rules) ? rules : [rules];
    this.option.rules = {};
    for (const rule of rules) {
      this.option.rules[rule] = { enabled: false };
    }
    return this;
  }
  /**
   * Use frameMessenger with <same_origin_only>
   *
   * This disables use of axe.runPartial() which is called in each frame, and
   * axe.finishRun() which is called in a blank page. This uses axe.run() instead,
   * but with the restriction that cross-origin frames will not be tested.
   */
  setLegacyMode(legacyMode = true) {
    this.legacyMode = legacyMode;
    return this;
  }
  /**
   * Performs an analysis and retrieves results.
   */
  async analyze(callback) {
    return new Promise((resolve, reject) => {
      return this.analyzePromise().then((results) => {
        callback?.(null, results);
        resolve(results);
      }).catch((err) => {
        if (callback) {
          callback(err.message, null);
        } else {
          reject(err);
        }
      });
    });
  }
  /**
   * Get axe-core source and configurations
   */
  get script() {
    return `
        ${this.axeSource}
        axe.configure({
          branding: { application: 'webdriverio' }
        })
        `;
  }
  /**
   * Injects `axe-core` into all frames.
   */
  async inject(browsingContext = null) {
    await this.setBrowsingContext(browsingContext);
    const runPartialSupported = await axeSourceInject(
      this.client,
      this.axeSource
    );
    if (!this.legacyMode && !runPartialSupported) {
      await configureAllowedOrigins(this.client);
    }
    const frames = await this.client.$$(this.frameSelector()) || [];
    const iframes = frames.concat(await this.client.$$(this.iframeSelector())) || [];
    if (!iframes.length) {
      return;
    }
    for (const iframe of iframes) {
      try {
        if (!await iframe.isExisting()) {
          continue;
        }
        await this.inject(iframe);
        await this.client.switchToParentFrame();
      } catch (error) {
        logOrRethrowError(error);
      }
    }
  }
  async analyzePromise() {
    const { client, axeSource } = this;
    const context = normalizeContext(
      this.includes,
      this.excludes,
      this.disableFrameSelectors
    );
    const runPartialSupported = await axeSourceInject(client, axeSource);
    if (!runPartialSupported || this.legacyMode) {
      return await this.runLegacy(context);
    }
    const { pageLoad } = await this.client.getTimeouts();
    this.client.setTimeout({
      pageLoad: FRAME_LOAD_TIMEOUT
    });
    let partials;
    try {
      partials = await this.runPartialRecursive(context);
    } finally {
      this.client.setTimeout({
        pageLoad
      });
    }
    try {
      return await this.finishRun(partials);
    } catch (error) {
      throw new Error(
        `${error.message}
 Please check out ${this.errorUrl}`
      );
    }
  }
  async runLegacy(context) {
    const { client, option } = this;
    await this.inject();
    return axeRunLegacy(client, context, option);
  }
  /**
   * Get a CSS selector for retrieving child iframes.
   */
  iframeSelector() {
    let selector = "iframe";
    for (const disableFrameSelector of this.disableFrameSelectors) {
      selector += `:not(${disableFrameSelector})`;
    }
    return selector;
  }
  /**
   * Get a CSS selector for retrieving child frames.
   */
  frameSelector() {
    let selector = "frame";
    for (const disableFrameSelector of this.disableFrameSelectors) {
      selector += `:not(${disableFrameSelector})`;
    }
    return selector;
  }
  /**
   * Set browsing context - when `null` sets top level page as context
   * - https://webdriver.io/docs/api/webdriver.html#switchtoframe
   */
  async setBrowsingContext(id = null) {
    if (id) {
      await this.client.switchToFrame(id);
    } else {
      await this.client.switchToParentFrame();
    }
  }
  /**
   * Get partial results from the current context and its child frames
   * @param {ContextObject} context
   */
  async runPartialRecursive(context, frameStack = []) {
    const frameContexts = await axeGetFrameContext(this.client, context);
    const partials = [
      await axeRunPartial(this.client, context, this.option)
    ];
    for (const { frameSelector, frameContext } of frameContexts) {
      try {
        const frame = await this.client.$(frameSelector);
        (0, import_assert2.default)(frame, `Expect frame of "${frameSelector}" to be defined`);
        await this.client.switchToFrame(frame);
        await axeSourceInject(this.client, this.script);
        partials.push(
          ...await this.runPartialRecursive(frameContext, [
            ...frameStack,
            frame
          ])
        );
      } catch (error) {
        const [topWindow] = await this.client.getWindowHandles();
        await this.client.switchToWindow(topWindow);
        for (const frameElm of frameStack) {
          await this.client.switchToFrame(frameElm);
        }
        partials.push(null);
      }
    }
    await this.client.switchToParentFrame();
    return partials;
  }
  async finishRun(partials) {
    const { client, axeSource, option } = this;
    const win = await client.getWindowHandle();
    const newWindow = await client.createWindow("tab");
    (0, import_assert2.default)(
      newWindow.handle,
      "Please make sure that you have popup blockers disabled."
    );
    try {
      await client.switchToWindow(newWindow.handle);
      await client.url("about:blank");
    } catch (error) {
      throw new Error(
        `switchToWindow failed. Are you using updated browser drivers? 
Driver reported:
${error.message}`
      );
    }
    const res = await axeFinishRun(client, axeSource, partials, option);
    await client.closeWindow();
    await client.switchToWindow(win);
    return res;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AxeBuilder
});

if (module.exports.default) {
  var ___default_export = module.exports.default;
  var ___export_entries = Object.entries(module.exports);
  module.exports = ___default_export;
  ___export_entries.forEach(([key, value]) => {
    if (module.exports[key]) {
      throw new Error(`Export "${key}" already exists on default export`);
    }

    module.exports[key] = value;
  });
}
